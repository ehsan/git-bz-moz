#!/usr/bin/env python
#
# git-bz - git subcommand to integrate with bugzilla
#
# Copyright (C) 2008  Owen Taylor
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, If not, see
# http://www.gnu.org/licenses/.
#
# Patches for git-bz
# ==================
# Send to Owen Taylor <otaylor@fishsoup.net>
#
# Installation
# ============
# Copy or symlink somewhere in your path.
#
# Documentation
# =============
# See http://git.fishsoup.net/man/git-bz.html
# (generated from git-bz.txt in this directory.)
#
DEFAULT_CONFIG = \
"""
default-assigned-to =
default-op-sys = All
default-platform = All
default-version = unspecified
"""

CONFIG = {}

CONFIG['bugs.freedesktop.org'] = \
"""
https = true
default-priority = medium
"""

CONFIG['bugzilla.gnome.org'] = \
"""
https = true
default-priority = Normal
"""

CONFIG['bugzilla.mozilla.org'] = \
"""
https = true
default-priority = --
"""

################################################################################

import base64
import bz
import bzauth
import getpass
import mercurial # for mercurial.error.Abort
from optparse import OptionParser
import os
import re
from splitreviewer import split_reviewer
from StringIO import StringIO
from subprocess import Popen, CalledProcessError, PIPE
import sys
import tempfile
import urlparse


# Globals
# =======

# options dictionary from optparse
global_options = None

# Utility functions for git
# =========================

# Run a git command
#    Non-keyword arguments are passed verbatim as command line arguments
#    Keyword arguments are turned into command line options
#       <name>=True => --<name>
#       <name>='<str>' => --<name>=<str>
#    Special keyword arguments:
#       _quiet: Discard all output even if an error occurs
#       _interactive: Don't capture stdout and stderr
#       _input=<str>: Feed <str> to stdinin of the command
#       _return_error: Return tuple of captured (stdout,stderr)
#
def git_run(command, *args, **kwargs):
    to_run = ['git', command.replace("_", "-")]

    interactive = False
    quiet = False
    input = None
    return_stderr = False
    for (k,v) in kwargs.iteritems():
        if k == '_quiet':
            quiet = True
        elif k == '_interactive':
            interactive = True
        elif k == '_return_stderr':
            return_stderr = True
        elif k == '_input':
            input = v
        elif v is True:
            if len(k) == 1:
                to_run.append("-" + k)
            else:
                to_run.append("--" + k.replace("_", "-"))
        elif v is False:
            continue
        else:
            to_run.append("--" + k.replace("_", "-") + "=" + v)

    to_run.extend(args)

    process = Popen(to_run,
                    stdout=(None if interactive else PIPE),
                    stderr=(None if interactive else PIPE),
                    stdin=(PIPE if (input != None) else None))
    output, error = process.communicate(input)
    if process.returncode != 0:
        if not quiet and not interactive:
            # Using print here could result in Python adding a stray space
            # before the next print
            sys.stderr.write(error)
            sys.stdout.write(output)
        raise CalledProcessError(process.returncode, " ".join(to_run))

    if interactive:
        return None
    elif return_stderr:
        return output.strip(), error.strip()
    else:
        return output.strip()

# Wrapper to allow us to do git.<command>(...) instead of git_run()
class Git:
    def __getattr__(self, command):
        def f(*args, **kwargs):
            return git_run(command, *args, **kwargs)
        return f

git = Git()

class GitCommit:
    def __init__(self, id, author, subject):
        self.id = id
        self.subject = subject
        self.author = author

    def should_fold(self):
        return self.subject.startswith("FOLD")

    def commit_range(self):
        return "%s^..%s" % (self.id, self.id)

class GitCommitRange:
    """A GitCommitRange is just like a GitCommit, except it has a start and an
    end id.  This class is used when folding patches.  The folded patches take
    the initial commit's subject and author, but their combined diff is over
    the range start^..end.

    """
    def __init__(self, commit):
        self.start = commit.id
        self.end = commit.id
        self.subject = commit.subject
        self.author = commit.author

    def fold(self, commit):
        # We assume that the last patch you fold in is the end of the range.
        self.end = commit.id

    def commit_range(self):
        return "%s^..%s" % (self.start, self.end)

def rev_list_commits(*args, **kwargs):
    kwargs_copy = dict(kwargs)
    kwargs_copy['pretty'] = 'format:%an <%ae>%n%s'
    output = git.rev_list(*args, **kwargs_copy)
    if output == "":
        lines = []
    else:
        lines = output.split("\n")
    if (len(lines) % 3 != 0):
        raise RuntimeException("git rev-list didn't return a number of lines divisible by 3")

    result = []
    for i in xrange(0, len(lines), 3):
        m = re.match("commit\s+([A-Fa-f0-9]+)", lines[i])
        if not m:
            raise RuntimeException("Can't parse commit it '%s'", lines[i])
        commit_id = m.group(1)
        author = lines[i + 1]
        subject = lines[i + 2]
        result.append(GitCommit(commit_id, author, subject))

    return result

def get_commits(commit_or_revision_range):
    # We take specifying a single revision to mean everything since that
    # revision, while git-rev-list lists that revision and all ancestors
    try:
        # See if the argument identifies a single revision
        rev = git.rev_parse(commit_or_revision_range, verify=True, _quiet=True)
        commits = rev_list_commits(rev, max_count='1')
    except CalledProcessError:
        # If not, assume the argument is a range
        commits = rev_list_commits(commit_or_revision_range)

    if len(commits) == 0:
        die("'%s' does not name any commits. Use HEAD to specify just the last commit" %
            commit_or_revision_range)

    return commits

def get_patch(commit_or_range):
    # We could pass through -M as an option, but I think you basically always
    # want it; showing renames as renames rather than removes/adds greatly
    # improves readability.

    return git.diff(commit_or_range.commit_range(),
                    ignore_all_space=global_options.ignore_all_space,
                    M=True, binary=True, unified="8", patience=True) + "\n"

def get_body(commit_or_range):
    return git.log(commit_or_range.commit_range(), pretty="format:%b")

def commit_is_merge(commit):
    contents = git.cat_file("commit", commit.id)
    parent_count = 0
    for line in contents.split("\n"):
        if line == "":
            break
        if line.startswith("parent "):
            parent_count += 1

    return parent_count > 1

# Global configuration variables
# ==============================

def get_tracker():
    if global_options.bugzilla != None:
        return global_options.bugzilla

    try:
        return git.config('bz.default-tracker', get=True)
    except CalledProcessError:
        return 'bugzilla.mozilla.org'

def get_default_product():
    try:
        return git.config('bz.default-product', get=True)
    except CalledProcessError:
        return None

def get_default_component():
    try:
        return git.config('bz.default-component', get=True)
    except CalledProcessError:
        return None

def get_add_url():
    try:
        return git.config('bz.add-url', get=True) == 'true'
    except CalledProcessError:
        return True

def get_add_url_method():
    try:
        return git.config('bz.add-url-method', get=True)
    except CalledProcessError:
        return "subject-prepend:Bug %d -"

def get_add_url_ignore_remote_commits():
    try:
        return git.config('bz.add-url-ignore-remote-commits', get=True) == 'true'
    except CalledProcessError:
        return False


# Per-tracker configuration variables
# ===================================

def resolve_host_alias(alias):
    try:
        return git.config('bz-tracker.' + alias + '.host', get=True)
    except CalledProcessError:
        return alias

def split_local_config(config_text):
    result = {}

    for line in config_text.split("\n"):
        line = re.sub("#.*", "", line)
        line = line.strip()
        if line == "":
            continue
        m = re.match("([a-zA-Z0-9-]+)\s*=\s*(.*)", line)
        if not m:
            die("Bad config line '%s'" % line)

        param = m.group(1)
        value = m.group(2)

        result[param] = value

    return result

def get_git_config(name):
    try:
        name = name.replace(".", r"\.")
        config_options = git.config(r'bz-tracker\.' + name + r'\..*', get_regexp=True)
    except CalledProcessError:
        return {}

    result = {}
    for line in config_options.split("\n"):
        line = line.strip()
        m = re.match("(\S+)\s+(.*)", line)
        key = m.group(1)
        value = m.group(2)

        m = re.match(r'bz-tracker\.' + name + r'\.(.*)', key)
        param = m.group(1)

        result[param] = value

    return result

# We only ever should be the config for one tracker in the course of a single run
cached_config = None
cached_config_tracker = None

def get_config(tracker):
    global cached_config
    global cached_config_tracker

    if cached_config == None:
        cached_config_tracker = tracker
        host = resolve_host_alias(tracker)
        cached_config = split_local_config(DEFAULT_CONFIG)
        if host in CONFIG:
            cached_config.update(split_local_config(CONFIG[host]))
        cached_config.update(get_git_config(host))
        if tracker != host:
            cached_config.update(get_git_config(tracker))

    assert cached_config_tracker == tracker

    return cached_config

def tracker_uses_https(tracker):
    config = get_config(tracker)
    return 'https' in config and config['https'] == 'true'

def tracker_get_path(tracker):
    config = get_config(tracker)
    if 'path' in config:
        return config['path']
    return ""

def get_default_fields(tracker):
    config = get_config(tracker)

    default_fields = {}

    for key, value in config.iteritems():
        if key.startswith("default-"):
            param = key[8:].replace("-", "_")
            default_fields[param] = value

    return default_fields

# Utility functions for bugzilla
# ==============================

class BugParseError(Exception):
    pass

# A BugHandle is the parsed form of a bug reference string; it
# uniquely identifies a bug on a server, though until we try
# to load it (and create a Bug) we don't know if it actually exists.
class BugHandle:
    def __init__(self, host, path, https, id):
        self.host = host
        self.path = path
        self.https = https
        self.id = id

        # ensure that the path to the bugzilla installation is an absolute path
        # so that it will still work even if their config option specifies
        # something like:
        #   path = bugzilla
        # instead of the proper form:
        #   path = /bugzilla
        if self.path and self.path[0] != '/':
            self.path = '/' + self.path

    def get_url(self):
        return "%s://%s%s/show_bug.cgi?id=%s" % ("https" if self.https else "http",
                                                 self.host,
                                                 self.path if self.path else "",
                                                 self.id)

    @staticmethod
    def parse(bug_reference):
        parseresult = urlparse.urlsplit (bug_reference)

        if parseresult.scheme in ('http', 'https'):
            # Catch http://www.gnome.org and the oddball http:relative/path and http:/path
            if len(parseresult.path) == 0 or parseresult.path[0] != '/' or parseresult.hostname is None:
                raise BugParseError("Invalid bug reference '%s'" % bug_reference)

            if parseresult.username:
                print 'Ignoring user name in URL.'
            if parseresult.password:
                print 'Ignoring password in URL.'

            # strip off everything after the last '/', so '/bugzilla/show_bug.cgi'
            # will simply become '/bugzilla'
            base_path = parseresult.path[:parseresult.path.rfind('/')]
            m = re.match("id=([^&]+)", parseresult.query)

            if m:
                return BugHandle(host=parseresult.hostname,
                                 path=base_path,
                                 https=parseresult.scheme=="https",
                                 id=m.group(1))

        colon = bug_reference.find(":")
        if colon > 0:
            tracker = bug_reference[0:colon]
            id = bug_reference[colon + 1:]
        else:
            tracker = get_tracker()
            id = bug_reference

        if not id.isdigit():
            raise BugParseError("Invalid bug reference '%s'" % bug_reference)

        host = resolve_host_alias(tracker)
        https = tracker_uses_https(tracker)
        path = tracker_get_path(tracker)

        if not re.match(r"^.*\.[a-zA-Z]{2,}$", host):
            raise BugParseError("'%s' doesn't look like a valid bugzilla host or alias" % host)

        return BugHandle(host=host, path=path, https=https, id=id)

    def get_bug_server(self):
        return get_bug_server(self.host, self.path, self.https)


    @staticmethod
    def parse_or_die(str):
        try:
            return BugHandle.parse(str)
        except BugParseError, e:
            die(e.message)

    def __hash__(self):
        return hash((self.host, self.https, self.id))

    def __eq__(self, other):
        return ((self.host, self.https, self.id) ==
                (other.host, other.https, other.id))


# General Utility Functions
# =========================

def make_filename(description):
    filename = re.sub(r"\s+", "-", description)
    filename = re.sub(r"[^A-Za-z0-9-]+", "", filename)
    filename = filename[0:50]

    return filename

def edit_file(filename):
    editor = git.var("GIT_EDITOR")
    process = Popen(editor + " " + filename, shell=True)
    process.wait()
    if process.returncode != 0:
        die("Editor exited with non-zero return code")

def edit_template(template):
    # Prompts the user to edit the text 'template' and returns list of
    # lines with comments stripped

    handle, filename = tempfile.mkstemp(".txt", "git-bz-")
    f = os.fdopen(handle, "w")
    f.write(template.encode("utf-8"))
    f.close()

    edit_file(filename)

    f = open(filename, "r")
    lines = filter(lambda x: not x.startswith("#"), f.readlines())
    f.close()

    # Save the last file in a known location in case we fail to attach the
    # patch for some reason.
    tmpdir = tempfile.gettempdir()
    target = os.path.join(tmpdir, "git-bz-last.txt")
    if os.path.exists(target):
        os.remove(target)
    os.rename(filename, target)

    return lines

def strip_lines(lines):
    # Strips leading and trailing lines of whitespace

    first_line = 0
    last_line = len(lines) - 1

    while first_line <= last_line:
        if len(lines[first_line].strip()):
            break
        first_line += 1

    while last_line >= first_line:
        if len(lines[last_line].strip()):
            break
        last_line -= 1

    return lines[first_line:last_line + 1]

def _shortest_unique_abbreviation(full, l):
    for i in xrange(1, len(full) + 1):
        abbrev = full[0:i]
        if not any((x != full and x.startswith(abbrev) for x in l)):
            return abbrev
    # Duplicate items or one item is a prefix of another
    raise ValueError("%s has no unique abbreviation in %s" % (full, l))

def _abbreviation_item_help(full, l):
    abbrev = _shortest_unique_abbreviation(full, l)
    return '[%s]%s' % (abbrev, full[len(abbrev):])

# Return '[a]pple, [pe]ar, [po]tato'
def abbreviation_help_string(l):
    return ", ".join((_abbreviation_item_help(full, l) for full in l))

# Find the unique element in l that starts with abbrev
def expand_abbreviation(abbrev, l):
    for full in l:
        if full.startswith(abbrev) and len(abbrev) >= len(_shortest_unique_abbreviation(full, l)):
            return full
    raise ValueError("No unique abbreviation expansion")

def prompt(message):
    while True:
        # Using print here could result in Python adding a stray space
        # before the next print
        sys.stdout.write(message + " [yn] ")
        line = sys.stdin.readline().strip()
        if line == 'y' or line == 'Y':
            return True
        elif line == 'n' or line == 'N':
            return False

def die(message):
    print >>sys.stderr, message
    sys.exit(1)


# Classes for bug handling
# ========================

class BugPatch(object):
    def __init__(self, attach_id):
        self.attach_id = attach_id


class NoXmlRpcError(Exception):
    pass


class ShimMercurialUI:
    def config(self, key1, key2, default=None):
        if key1 != 'bugzilla':
            print 'Expected bugzilla for first argument to config.'
            exit(-1)
        try:
            return git.config('bz.' + key2, get=True)
        except CalledProcessError:
            return default

    def configlist(self, key1, key2, arg3):
        if key1 != 'bugzilla':
            print 'Expected bugzilla for first argument to configlist.'
            exit(-1)
        if key2 != 'firefoxprofile':
            print 'Expected firefoxprofile for second argument to configlist.'
            exit(-1)
        if len(arg3) != 0:
            print 'Expected [] for third argument to configlist.'
        # Don't try to support this.
        return None

    def debug(self, msg):
        print 'Debug:', msg

    def getpass(self, message, default=None):
        return getpass.getpass(message)

    def prompt(self, message, default=None):
        sys.stdout.write(message + ' ')
        line = sys.stdin.readline().strip()
        if line == '':
            return default
        return line

    def warn(self, msg):
        print 'Warn:', msg

    def write(self, msg):
        print msg

    def write_err(self, msg):
        print 'Error:', msg


class BugServer(object):
    def __init__(self, host, path, https):
        self.bugzilla = "%s://%s%s/" % ("https" if https else "http", host, path)
        self.api_server = '%s/bzapi/' % self.bugzilla.rstrip('/')
        self.ui = ShimMercurialUI()

        # Ideally, have a config option to stop the message spam for people
        # who prefer to enter things manually.
        if not self.ui.config('bugzilla', 'username'):
            print 'Your bugzilla username is not specified in your git config.'
            print 'Set it by running:'
            print '  git config --global bz.username <your username>'
            print
        if not self.ui.config('bugzilla', 'apikey'):
            print 'No bugzilla API key is specified in your git config. This is the'
            print 'preferred means of authentication, and other methods may break at'
            print 'any time. An API key can be obtained here:'
            print '  https://bugzilla.mozilla.org/userprefs.cgi?tab=apikey'
            print 'Once obtained, set the API key by running:'
            print '  git config --global bz.apikey <your bugzilla API key>'
            print

        try:
            self.auth = bzauth.get_auth(self.ui, self.bugzilla, None)
        except mercurial.error.Abort, e:
            print 'Error:', e
            exit(-1)

    def get_attachments(self, bugid, attachment_data=False):
        try:
            request = 'bug/%s/attachment' % bugid
            if not attachment_data:
                request = request + '?exclude_fields=data'
            return self.auth.rest_request('GET', request)['bugs'][bugid]
        except mercurial.error.Abort, e:
            print 'Error:', e
            exit(-1)

    def get_bug(self, bugid):
        try:
            return bz.get_bug(self.auth, bugid)
        except mercurial.error.Abort, e:
            print 'Error:', e
            exit(-1)

    def get_product_components(self, product):
        try:
            request_string = 'product/{0}?include_fields=components.name'.format(product)
            product_info = self.auth.rest_request('GET', request_string)['products']
            assert len(product_info) == 1
            component_info = product_info[0]['components']
            component_list = [x['name'] for x in component_info]
            component_list.sort()
            return component_list
        except mercurial.error.Abort, e:
            print 'Error:', e
            exit(-1)

    def legal_field_values(self, field_name):
        # XXX Should cache this.
        vals = self.auth.rest_request('GET', 'field/bug/' + field_name + '?include_fields=values')
        vals = vals['fields'][0]['values']
        return [x['name'] for x in vals]

    # Note that if a comment is given when obsoleting multiple attachments,
    # the comment will be posted repeatedly. See bug 1206797.
    def obsolete_attachments_by_id(self, attachment_ids, comment=''):
        if not attachment_ids:
            return
        try:
            o = {
                'ids': attachment_ids,
                'is_obsolete': True,
            }
            if comment:
                o['comment'] = comment

            return self.auth.rest_request('PUT', 'bug/attachment/%s' % attachment_ids[0], data=o)
        except mercurial.error.Abort, e:
            print 'Error:', e
            exit(-1)

    def update_bug(self, bug_id, changes):
        bz.update_bug(self.auth, bug_id, changes)

    def send_post(self, url, fields, files=None):
        die('unimplemented')


servers = {}

def get_bug_server(host, path, https):
    identifier = (host, path, https)
    if not identifier in servers:
        servers[identifier] = BugServer(host, path, https)

    return servers[identifier]

def tracker_get_bug_server(tracker):
    host = resolve_host_alias(tracker)
    path = tracker_get_path(tracker)
    https = tracker_uses_https(tracker)
    return get_bug_server(host, path, https)

def check_for_success(response, response_data, *args):
    die('unimplemented')


class BugAttachment:
    def __init__(self, raw_attachment):
        self.attach_id = raw_attachment['id']
        self.description = raw_attachment['summary']
        self.flag_requestees = set(flag.get('requestee') for flag in raw_attachment['flags'])
        if 'data' in raw_attachment:
            self.data = base64.b64decode(raw_attachment['data'])
        else:
            self.data = None


class Bug(object):
    def __init__(self, server):
        self.server = server
        self.id = None
        self.product = None
        self.component = None
        self.short_desc = None
        self.patches = []

    def _load(self, bugid, attachment_data=False):
        buginfo = self.server.get_bug(bugid)
        self.id = buginfo['id']
        self.product = buginfo['product']
        self.component = buginfo['component']
        self.short_desc = buginfo['summary']
        self.bug_status = buginfo['status']
        if self.bug_status == "RESOLVED":
            self.resolution = buginfo['resolution']

        attachments = self.server.get_attachments(bugid, attachment_data=attachment_data)
        for a in attachments:
            if not a["is_patch"]:
                continue
            if a["is_obsolete"]:
                continue
            self.patches.append(BugAttachment(a))

    def get_attachment_token(self):
        die('unimplemented')

    def _create_via_xmlrpc(self, product, component, short_desc, comment, default_fields):
        params = dict()
        params['product'] = product
        params['component'] = component
        params['summary'] = short_desc
        params['description'] = comment
        for (field, value) in default_fields.iteritems():
            params[field] = value

        try:
            response = self.server.get_xmlrpc_proxy().Bug.create(params)
            self.id = response['id']
        except xmlrpclib.Fault, e:
            die(e.faultString)
        except xmlrpclib.ProtocolError, e:
            if e.errcode == 404:
                raise NoXmlRpcError(e.errmsg)
            else:
                print >>sys.stderr, "Problem filing bug via XML-RPC: %s (%d)\n" % (e.errmsg, e.errcode)
                print >>sys.stderr, "falling back to form post\n"
                raise NoXmlRpcError("Communication error")

    def _create_with_form(self, product, component, short_desc, comment, default_fields):
        fields = dict()
        fields['product'] = product
        fields['component'] = component
        fields['short_desc'] = short_desc
        fields['comment'] = comment

        # post_bug.cgi wants some names that are less congenial than the names
        # expected in XML-RPC.
        for (field, value) in default_fields.iteritems():
            if field == 'severity':
                field = 'bug_severity'
            elif field == 'platform':
                field = 'rep_platform'
            fields[field] = value

        # Priority values vary wildly between different servers because the stock
        # Bugzilla uses the awkward P1/../P5. It will be defaulted on the XML-RPC
        # code path, but we need to take a wild guess here.
        if not 'priority' in fields:
            fields['priority'] = 'P5'
        # Legal severity values are much more standardized, but not specifying it
        # in the XML-RPC code path allows the server default to win. We need to
        # specify something here.
        if not 'severity' in fields:
            fields['bug_severity'] = 'normal'
        # Required, but a configured default doesn't make any sense
        if not 'bug_file_loc' in fields:
            fields['bug_file_loc'] = ''

        response = self.server.send_post("/post_bug.cgi", fields)
        response_data = response.read()
        m = check_for_success(response, response_data,
                              r"<title>\s*Bug\s+([0-9]+)")
        if not m:
            print response_data
            die("Failed to create bug, status=%d" % response.status)

        self.id = int(m.group(1))

    def _create(self, product, component, short_desc, comment, default_fields):
        try:
            self._create_via_xmlrpc(product, component, short_desc, comment, default_fields)
        except NoXmlRpcError:
            self._create_with_form(product, component, short_desc, comment, default_fields)

        print "Successfully created"
        print "Bug %d - %s" % (self.id, short_desc)
        print self.get_url()

    def create_patch(self, description, comment, filename, data, obsoletes=[], review=[], superreview=[], feedback=[], ui_review=[]):
        fields = {}
        fields['bugid'] = str(self.id)
        token = self.get_attachment_token()
        if token:
          fields['token'] = token
        fields['action'] = 'insert'
        fields['ispatch'] = '1'
        fields['description'] = description
        if comment:
            fields['comment'] = comment
        if obsoletes:
            # this will produce multiple parts in the encoded data with the
            # name 'obsolete' for each item in the list
            fields['obsolete'] = map(str, obsoletes)

        # Support for flagging for review/superreview/feedback/ui-review. I have
        # no idea if this works on installations other than
        # bugzilla.mozilla.org. These flag numbers are specified at
        # https://api-dev.bugzilla.mozilla.org/latest/configuration.
        # Note that the Firefox component for some reason uses a review flag with
        # ID 748.  We submit both at the same time, and the server picks the one
        # that applies to the component.
        review_flag = 4
        firefox_review_flag = 748
        superreview_flag = 5
        feedback_flag = 607
        ui_review_flag = 203
        if review:
            if review[0] == ':me+':
                fields['flag_type-%d' % review_flag] = '+'
                fields['flag_type-%d' % firefox_review_flag] = '+'
            else:
                fields['flag_type-%d' % review_flag] = '?'
                fields['flag_type-%d' % firefox_review_flag] = '?'
                fields['requestee_type-%d' % review_flag] = ",".join(review)
                fields['requestee_type-%d' % firefox_review_flag] = ",".join(review)
        if superreview:
            if superreview[0] == ':me+':
                fields['flag_type-%d' % superreview_flag] = '+'
            else:
                fields['flag_type-%d' % superreview_flag] = '?'
                fields['requestee_type-%d' % superreview_flag] = ",".join(superreview)
        if feedback:
            if feedback[0] == ':me+':
                fields['flag_type-%d' % feedback_flag] = '+'
            else:
                fields['flag_type-%d' % feedback_flag] = '?'
                fields['requestee_type-%d' % feedback_flag] = ",".join(feedback)
        if ui_review:
            if ui_review[0] == ':me+':
                fields['flag_type-%d' % ui_review_flag] = '+'
            else:
                fields['flag_type-%d' % ui_review_flag] = '?'
                fields['requestee_type-%d' % ui_review_flag] = ",".join(ui_review)

        files = { 'data': (filename, 'text/plain; charset=UTF-8', data) }

        response = self.server.send_post("/attachment.cgi", fields, files)
        response_data = response.read()
        if not check_for_success(response, response_data,
                                 # Older bugzilla's used this for successful attachments
                                 r"<title>\s*Changes\s+Submitted",
                                 # Newer bugzilla's, use, instead:
                                 r"<title>\s*Attachment\s+\d+\s+added"):
            response_match = re.search("<title>([^<]+)</title>", response_data)
            if response_match:
                print 'Error response from bugzilla:', response_match.group(1)
            else:
                print 'Error response from bugzilla.'
            die ("Failed to attach patch to bug %d, status=%d" % (self.id, response.status))

        print "Attached %s" % filename

    def get_url(self):
        return "%sshow_bug.cgi?id=%d" % (self.server.bugzilla, self.id)

    def update(self, changes):
        self.server.update_bug(self.id, changes)

    @staticmethod
    def load(bug_reference, attachment_data=False):
        server = bug_reference.get_bug_server()
        bug = Bug(server)
        bug._load(bug_reference.id, attachment_data)

        return bug

    @staticmethod
    def create(tracker, product, component, short_desc, comment):
        server = tracker_get_bug_server(tracker)
        default_fields = get_default_fields(tracker)
        bug = Bug(server)
        bug._create(product, component, short_desc, comment, default_fields)

        return bug

# The Commands
# =============

def commit_needs_url(commit, bug_id):
    pat = re.compile(r"(?<!\d)%d(?!\d)" % bug_id)
    return (pat.search(commit.subject) is None and
            pat.search(get_body(commit)) is None)

def check_add_url(commits, bug_id=None, is_add_url=False):
    if bug_id != None:
        # We only need to check the commits that we'll add the URL to
        commits = [commit for commit in commits if commit_needs_url(commit, bug_id)]

    if len(commits) == 0: # Nothing to do
        return

    try:
        git.diff(exit_code=True, ignore_submodules=True, _quiet=True)
        git.diff(exit_code=True, ignore_submodules=True, cached=True,  _quiet=True)
    except CalledProcessError:
        die("Cannot add bug reference to commit message(s); You must commit (or stash) all changes first")

    for commit in commits:
        # check that the commit is an ancestor of the current revision
        base = git.merge_base("HEAD", commit.id)
        if base != commit.id:
            die("%s %s\nNot an ancestor of HEAD, can't add bug URL to it" % (commit.id[0:7], commit.subject))

        if not get_add_url_ignore_remote_commits():
            # see if the commit is present in any remote branches
            remote_branches = git.branch(contains=commit.id, r=True)
            if remote_branches != "":
                print commit.id[0:7], commit.subject
                print "Commit is already in remote branch(es):", " ".join(remote_branches.split())
                if not prompt("Rewrite the commit add the bug URL anyways?"):
                    if is_add_url:
                        print "Aborting."
                    else:
                        print "Aborting. You can use -n/--no-add-url to turn off adding the URL"
                    sys.exit(0)

    # Check for merge commits
    oldest_commit = commits[-1]
    all_commits = rev_list_commits(commits[-1].id + "^..HEAD")
    for commit in all_commits:
        if commit_is_merge(commit):
            print "Found merge commit:"
            print commit.id[0:7], commit.subject
            print "Can't rewrite this commit or an ancestor commit to add bug URL"
            sys.exit(1)

def bad_url_method(add_url_method):
    die("""add-url-method '%s' is invalid
Should be [subject-prepend|subject-append|body-prepend|body-append]:<format>""" %
        add_url_method)

def add_url_to_subject_body(subject, body, bug):
    add_url_method = get_add_url_method()
    if not ':' in add_url_method:
        bad_url_method(add_url_method)

    method, format = add_url_method.split(':', 1)

    def sub_percent(m):
        if m.group(1) == 'u':
            return bug.get_url()
        elif m.group(1) == 'd':
            return str(bug.id)
        elif m.group(1) == 'n':
            return "\n"
        elif m.group(1) == '%':
            return "%"
        else:
            die("Bad add-url-method escape %%%s" % m.group(1))

    formatted = re.sub("%(.)", sub_percent, format)

    if method == 'subject-prepend':
        subject = formatted + " " + subject
    elif method == 'subject-append':
        subject = subject + " " + formatted
    elif method == 'body-prepend':
        body = formatted + "\n\n" + body
    elif method == 'body-append':
        body = body + "\n\n" + formatted
    else:
        bad_url_method(add_url_method)

    return subject, body

def validate_add_url_method(bug):
    # Dry run
    add_url_to_subject_body("", "", bug)

def add_url_to_head_commit(commit, bug):
    subject = commit.subject
    body = get_body(commit)

    subject, body = add_url_to_subject_body(subject, body, bug)

    input = subject + "\n\n" + body
    git.commit(file="-", amend=True, _input=input)

def add_url(bug, commits):
    commit_map = {}
    oldest_commit = None
    for commit in commits:
        commit_map[commit.id] = commit
        if commit_needs_url(commit, bug.id):
            oldest_commit = commit

    if not oldest_commit:
        return

    # Check that the add-url method is valid before starting the rebase
    validate_add_url_method(bug)

    all_commits = rev_list_commits(oldest_commit.id + "^..HEAD")
    orig_head = all_commits[0].id

    try:
        branch_name = git.symbolic_ref("HEAD", q=True)
    except CalledProcessError:
        branch_name = None
    try:
        # Detach HEAD from the branch; this gives a cleaner reflog for the branch
        print "Moving to starting point"
        git.checkout(oldest_commit.id + "^", q=True)

        for commit in reversed(all_commits):
            # Map back to the original commit object so we can update it
            if commit.id in commit_map:
                commit = commit_map[commit.id]

            if commit.id in commit_map and commit_needs_url(commit, bug.id):
                print "Adding bug reference  ", commit.id[0:7], commit.subject
                git.cherry_pick(commit.id)
                add_url_to_head_commit(commit, bug)
            else:
                if commit.id in commit_map:
                    print "Recommitting", commit.id[0:7], commit.subject, "(already has bug #)"
                else:
                    print "Recommitting", commit.id[0:7], commit.subject
                git.cherry_pick(commit.id)

            # Get the commit ID; we update the commit with the new ID, so we in the case
            # where we later format the patch, we format the patch with the added bug URL
            new_head = commit.id = git.rev_parse("HEAD")

        if branch_name is not None:
            git.update_ref("-m", "bz add-url: adding references to %s" % bug.get_url(),
                           branch_name, new_head)
            git.symbolic_ref("HEAD", branch_name)
    except:
        print "Cleaning up back to original state on error"
        git.reset(orig_head, hard=True)
        if branch_name is not None:
            git.symbolic_ref("HEAD", branch_name)
        raise

def do_add_url(bug_reference, commit_or_revision_range):
    commits = get_commits(commit_or_revision_range)

    bug = Bug.load(BugHandle.parse_or_die(bug_reference))

    check_add_url(commits, bug.id, is_add_url=True)

    print "Bug %d - %s" % (bug.id, bug.short_desc)
    print bug.get_url()
    print

    found = False
    for commit in commits:
        if commit_needs_url(commit, bug.id):
            print commit.id[0:7], commit.subject
            found = True
        else:
            print "SKIPPING", commit.id[0:7], commit.subject
    if not found:
        sys.exit(0)

    print
    if not prompt("Add bug URL to above commits?"):
        print "Aborting"
        sys.exit(0)

    print
    add_url(bug, commits)

def requestee_match(requestees):
    # No --requestee flag means we take all patches
    if not global_options.requestee:
        return True

    # If we specify an exact match, see if we're in the requestees
    if global_options.requestee in requestees:
        return True

    # If we specify a partial (user-name) match, see if we match the
    # user-name of any requestee. Eg: a requestee of 'foo' will match
    # foo@example.com, but not foobar@example.com
    if '@' not in global_options.requestee:
        for requestee in requestees:
            if requestee.startswith(global_options.requestee + '@'):
                return True
    return False

def do_apply(bug_reference):
    bug = Bug.load(BugHandle.parse_or_die(bug_reference),
                   attachment_data=True)

    print "Bug %d - %s" % (bug.id, bug.short_desc)
    print

    for patch in bug.patches:
        if not requestee_match(patch.flag_requestees):
            print "Skipping patch for %s: %s" % (patch.flag_requestees,
                                                 patch.description)
            continue

        print patch.description
        if not prompt("Apply?"):
            continue

        print

        handle, filename = tempfile.mkstemp(".patch", make_filename(patch.description) + "-")
        f = os.fdopen(handle, "w")
        f.write(patch.data)
        f.close()

        try:
            process = git.am(filename, _interactive=True)
        except CalledProcessError:
            print "Patch left in %s" % filename
            break

        os.remove(filename)

        if global_options.add_url:
            # Slightly hacky, would be better to just commit right the first time
            commits = rev_list_commits("HEAD^!")
            add_url(bug, commits)

def strip_bug_prefix(bug, description):
    # Strip any Bug XXXXXX prefix in a short description
    pattern = r"^\s*[Bb](ug)?\s*=?\s*%s\s*[\-:,]?\s*" % (bug.id)
    return re.sub(pattern, "", description)

def strip_bug_url(bug, commit_body):
    # Strip off the trailing bug URLs we add with -u; we do this before
    # using commit body in as a comment; doing it by stripping right before
    # posting means that we are robust against someone running add-url first
    # and attach second.
    pattern = "\s*" + re.escape(bug.get_url()) + "\s*$"
    return re.sub(pattern, "", commit_body)

def edit_attachment_comment(bug, initial_description, initial_body, initial_comment):
    [no_reviewer_description, reviewers] = split_reviewer(initial_description)

    template = StringIO()
    template.write("# Attachment to Bug %d - %s\n\n" % (bug.id, bug.short_desc))
    template.write("# Please edit the attachment description (first line) and comment (other lines).\n")
    template.write("# Lines starting with '#' will be ignored.  Delete everything to abort.\n\n")
    template.write(strip_bug_prefix(bug, no_reviewer_description))
    template.write("\n\n")
    template.write(initial_comment)
    template.write("\n\n")
    template.write("# Lines following 'Commit-Message:' will be included as the extended commit message\n")
    template.write("# in the attached patch. Comment this out to re-use the attachment name/description.\n\n")
    template.write("Commit-Message: %s\n\n" % initial_description)
    template.write(initial_body)
    template.write("\n\n")
    for r in reviewers:
        template.write("#Review: :" + r + "\n")
    try:
        for reviewer in git.config('bz.reviewer', get_all=True).split('\n'):
            template.write("#Review: %s\n" % reviewer)
    except CalledProcessError:
        template.write("#Review: reviewer1@example.com\n")
        template.write("#Review: reviewer2@example.com\n")
    template.write("#Review: :me+\n\n")

    try:
        for reviewer in git.config('bz.superreviewer', get_all=True).split('\n'):
            template.write("#Super-Review: %s\n" % reviewer)
    except CalledProcessError:
        template.write("#Super-Review: superreviewer@example.com\n")
    template.write("#Super-Review: :me+\n\n")

    try:
        for feedbacker in git.config('bz.feedbacker', get_all=True).split('\n'):
            template.write("#Feedback: %s\n" % feedbacker)
    except CalledProcessError:
        template.write("#Feedback: feedbacker@example.com\n")
    template.write("#Feedback: :me+\n\n")

    try:
        for feedbacker in git.config('bz.ui-review', get_all=True).split('\n'):
            template.write("#ui-review: %s\n" % feedbacker)
    except CalledProcessError:
        template.write("#ui-review: feedbacker@example.com\n")
    template.write("#ui-review: :me+\n\n")

    if len(bug.patches) > 0:
        for patch in bug.patches:
            template.write("#Obsoletes: %d - %s\n" % (patch.attach_id, patch.description))
        template.write("\n")

    if len(bug.patches) > 0:
        template.write("# To obsolete existing patches, uncomment the appropriate lines.\n")


    lines = edit_template(template.getvalue())

    obsoletes = []
    review = []
    superreview = []
    feedback = []
    ui_review = []

    commit_message = []
    comment_lines = []

    for line in lines:
        # Capture a |Metadata:| formatted line and stuff it into the relevant
        # list
        def append_matching_group(key, list, line, content_regexp='.+'):
            match = re.match("^\s*%s\s*:\s*(%s)" % (key, content_regexp), line)
            if match:
                list.append(match.group(1).strip())
                return True
            return False

        if append_matching_group("Obsoletes", obsoletes, line, content_regexp="[\d]+") or \
           append_matching_group("Review", review, line) or \
           append_matching_group("Super-Review", superreview, line) or \
           append_matching_group("Feedback", feedback, line) or \
           append_matching_group("ui-review", ui_review, line) or \
           append_matching_group("Commit-Message", commit_message, line):
            continue

        # The Commit-Message: line delineates the break between the attachment
        # description and the commit message and body
        if len(commit_message):
            commit_message.append(line)
        else:
            comment_lines.append(line)

    obsoletes = map(int, obsoletes)

    comment_lines = strip_lines(comment_lines)
    if not len(comment_lines):
        die("Empty description, aborting")

    description = comment_lines[0]
    comment = "".join(comment_lines[1:]).strip()

    # Don't strip_lines(commit_message) because its first member is the
    # Commit-Message: line, empty or no
    if commit_message:
        if not len(commit_message[0].strip()):
            die("Empty commit message, aborting")
        commit_body = "".join(commit_message[1:]).strip()
        commit_message = commit_message[0].strip()
    else:
        # If Commit-Message is commented out entirely, just reuse the attachment
        # desc/comment
        commit_message = description
        commit_body = comment

    return description, comment, commit_message, commit_body, obsoletes, \
           review, superreview, feedback, ui_review

def attach_commits(bug, commits, fill_comment=True, edit=False):
    # We want to attach the patches in chronological order
    commits = list(commits)
    commits.reverse()

    if commits and commits[0].should_fold():
        die("Can't fold first commit into non-existant commit above it.")

    commit_ranges = []
    for commit in commits:
        if not commit.should_fold():
            commit_ranges.append(GitCommitRange(commit))
        else:
            commit_ranges[-1].fold(commit)

    for commit_range in commit_ranges:
        filename = make_filename(commit_range.subject) + ".patch"
        patch = get_patch(commit_range)
        commit_body = get_body(commit_range)
        if fill_comment:
            comment = strip_bug_url(bug, commit_body)
        else:
            comment = None
        if edit:
            description, comment, commit_message, commit_body, obsoletes, \
                review, superreview, feedback, ui_review = \
                    edit_attachment_comment(bug, commit_range.subject, commit_body, comment)
        else:
            description = strip_bug_prefix(bug, commit_range.subject)
            commit_message = commit_range.subject
            obsoletes = []
            review = []
            superreview = []
            feedback = []
            ui_review = []
        # Prepend the body
        if commit_body:
            patch = commit_body + "\n\n" + patch
        # Prepend the commit message
        if commit_message:
            patch = commit_message + "\n\n" + patch
        # Prepend the author information in HG patch format.
        hgstring = '# HG changeset patch\n'
        hgstring += "# User " + commit_range.author + '\n\n'
        patch = hgstring + patch + '\n'

        bug.create_patch(description, comment, filename, patch, obsoletes=obsoletes, review=review, superreview=superreview, feedback=feedback, ui_review=ui_review)

def _get_commits_and_handle(args):
    if len(args) == 1:
        commit_or_revision_range = args[0]
        commits = get_commits(commit_or_revision_range)

        extracted = list(extract_and_collate_bugs(commits))
        if len(extracted) == 0:
            die("No bug references found in specified commits")
        elif len(extracted) > 1:
            # This could be sensible in the case of "attach updated patches
            # for all these commits", but for now, just make it an error
            die("Found multiple bug references specified commits:\n  " +
                "\n  ".join((handle.get_url() for handle, _ in extracted)))

        # extract_and_collate_bugs returns a list of commits that reference
        # the handle, but we ignore that - we want to attach all of the
        # specified commits, even if only some of the reference the bug
        handle, _ = extracted[0]
    else:
        bug_reference = args[0]
        commit_or_revision_range = args[1]

        commits = get_commits(commit_or_revision_range)
        handle = BugHandle.parse_or_die(bug_reference)
    return [commits, handle]

def do_attach(*args):
    commits, handle = _get_commits_and_handle(args)

    bug = Bug.load(handle)

    if global_options.add_url:
        check_add_url(commits, bug.id, is_add_url=False)
        add_url(bug, commits)
        # Try to get the commits again, in case the user has used symbolic refs,
        # to ensure that we pick the commits after the rebase.
        commits, handle = _get_commits_and_handle(args)

    # We always want to prompt if the user has specified multiple attachments.
    # For the common case of one attachment don't prompt if we are going
    # to give them a chance to edit and abort anyways.
    if len(commits) > 1 or not global_options.edit:
        template = StringIO()
        template.write("""# Bug %(id)d - %(short_desc)s
#
# Lines starting with '#' will be ignored.  Delete everything to abort.
#
# Commits to be attached:

""" % { 'id': bug.id, 'short_desc': bug.short_desc })

        commit_lines = []
        for commit in reversed(commits):
            commit_line = commit.id[0:7] + " " + commit.subject + "\n"
            commit_lines.append(commit_line)
            template.write(commit_line)

        lines = edit_template(template.getvalue()) # lines are not stripped.

        to_attach = []
        for commit_line, commit in zip(reversed(commit_lines), commits):
            if commit_line in lines:
                to_attach.append(commit)

        if not to_attach:
            die("No commits to attach, aborting")

        commits = to_attach

    attach_commits(bug, commits, edit=global_options.edit)

def edit_bug(bug):
    newly_applied_patches = obsoleted_patches = set()

    template = StringIO()
    template.write("# Bug %d - %s - %s" % (bug.id, bug.short_desc, bug.bug_status))
    if bug.bug_status == "RESOLVED":
        template.write(" - %s" % bug.resolution)
    template.write("\n")
    template.write("# %s\n" % bug.get_url())
    template.write("# Enter comment on following lines; delete everything to abort\n\n")

    for patch in bug.patches:
        if patch in newly_applied_patches:
            commit = newly_applied_patches[patch]
            template.write("Attachment %d pushed as %s - %s\n" % (patch.attach_id, commit.id[0:7], commit.subject))

    if bug.bug_status == "RESOLVED":
        template.write("# Uncommment and edit to change resolution\n")
    else:
        template.write("# Uncomment to resolve bug\n")
    legal_resolutions = bug.server.legal_field_values('resolution')
    if legal_resolutions:
        # Require non-empty resolution. DUPLICATE, MOVED would need special support
        legal_resolutions = [x for x in legal_resolutions if x not in ('', 'DUPLICATE', 'MOVED')]
        template.write("# possible resolutions: %s\n" % abbreviation_help_string(legal_resolutions))
    template.write("# Resolution: FIXED\n")

    if len(bug.patches) > 0:
        template.write("\n# To mark patches obsolete, uncomment below\n")
        for patch in bug.patches:
            template.write("#obsolete @%d - %s\n" % (patch.attach_id, patch.description))

        template.write("\n")

    lines = edit_template(template.getvalue())

    def filter_line(line):
        m = re.match("^\s*Resolution\s*:\s*(\S+)", line)
        if m:
            resolutions.append(m.group(1))
            return False
        m = re.match("^\s*(\S+)\s*@\s*(\d+)", line)
        if m:
            status = m.group(1)
            if status == 'obsolete':
                obsoleted_attachments.append(int(m.group(2)))
                return False
        return True

    obsoleted_attachments = []
    resolutions = []

    lines = filter(filter_line, lines)

    comment = "".join(lines).strip()
    resolution = resolutions[0] if len(resolutions) > 0 else None

    if resolution is None and len(obsoleted_attachments) == 0 and comment == "":
        print "No changes, not editing Bug %d - %s" % (bug.id, bug.short_desc)
        return False

    bug_changes = {}
    if resolution is not None:
        if legal_resolutions:
            try:
                resolution = expand_abbreviation(resolution, legal_resolutions)
            except ValueError:
                die("Bad resolution: %s" % resolution)
        bug_changes['resolution'] = resolution

    if comment:
        # If we're updating the bug anyways, add the comment at the
        # same time. If we're obsoleting multiple attachments at once,
        # add the comment separately so that it isn't added once per
        # attachment. See bug 1206797. Finally, if we are only adding
        # a comment, make sure we update the bug.
        if bug_changes or len(obsoleted_attachments) != 1:
            bug_changes['comment'] = { 'body': comment }
            comment = ''

    if bug_changes:
        bug.update(bug_changes)

    if obsoleted_attachments:
        assert len(obsoleted_attachments) == 1 or not comment
        bug.server.obsolete_attachments_by_id(obsoleted_attachments, comment)

    if resolution is not None:
        print "Resolved as %s bug %d - %s" % (resolution, bug.id, bug.short_desc)
    elif len(obsoleted_attachments) > 0:
        print "Obsoleted attachments on bug %d - %s" % (bug.id, bug.short_desc)
    else:
        print "Added comment to bug %d - %s" % (bug.id, bug.short_desc)
    print bug.get_url()

    return True

LOG_BUG_REFERENCE = re.compile(r"""
(\b[Ss]ee\s+(?:[^\s:/]+\s+){0,2})?
(?:(https?://[^/]+/show_bug.cgi\?id=[^&\s]+)
     |
   [Bb]ug\s+\#?(\d+))
""", re.VERBOSE | re.DOTALL)

def extract_bugs_from_string(str):
    refs = []
    for m in LOG_BUG_REFERENCE.finditer(str):
        bug_reference = None

        # If something says "See http://bugzilla.gnome.org/..." or
        # "See mozilla bug http://bugzilla.mozilla.org/..." or "see
        # bug 12345" - anything like that - then it's probably talking
        # about some peripherally related bug. So, if the word see
        # occurs 0 to 2 words before the bug reference, we ignore it.
        if m.group(1) is not None:
            print "Skipping cross-reference '%s'" % m.group(0)
            continue
        if m.group(2) is not None:
            bug_reference = m.group(2)
        else:
            bug_reference = m.group(3)

        try:
            yield BugHandle.parse(bug_reference)
        except BugParseError, e:
            print "WARNING: cannot resolve bug reference '%s'" % bug_reference

def extract_bugs_from_commit(commit):
    for handle in extract_bugs_from_string(commit.subject):
        yield handle
    for handle in extract_bugs_from_string(get_body(commit)):
        yield handle

# Yields bug, [<list of commits where it is referenced>] for each bug
# referenced in the list of commits. The order of bugs is the same as the
# order of their first reference in the list of commits
def extract_and_collate_bugs(commits):
    bugs_to_commits = {}

    for commit in commits:
        for handle in extract_bugs_from_commit(commit):
            bugs_to_commits.setdefault(handle, []).append(commit)

    return bugs_to_commits.iteritems()

def do_edit(bug_reference_or_revision_range):
    try:
        handle = BugHandle.parse(bug_reference_or_revision_range)
        bug = Bug.load(handle)
        edit_bug(bug)
    except BugParseError, e:
        try:
            commits = get_commits(bug_reference_or_revision_range)
        except CalledProcessError:
            die("'%s' isn't a valid bug reference or revision range" % bug_reference_or_revision_range)

        # Process from oldest to newest
        commits.reverse()
        for handle, commits in extract_and_collate_bugs(commits):
            bug = Bug.load(handle)
            edit_bug(bug)

PRODUCT_COMPONENT_HELP = """

Use:

  git config bz.default-product <product>
  git config bz.default-component <component>

to configure a default product and/or component for this module."""

def do_file(*args):
    if len(args) == 1:
        product_component, commit_or_revision_range = None, args[0]
    else:
        product_component, commit_or_revision_range = args[0], args[1]

    config = get_config(get_tracker())

    if product_component:
        product_component_split = product_component.split("/", 1)
        if len(product_component_split) == 1:
            product = None
            component = product_component
        else:
            assert len(product_component_split) == 2
            (product, component) = product_component_split

        if not product:
            product = get_default_product()

        if not product:
            die("'%s' does not specify a product and no default product is configured" % product_component
                + PRODUCT_COMPONENT_HELP)
    else:
        product = get_default_product()
        component = get_default_component()

        if not product:
            die("[<product>/]<component> or revision not specified and no default product is configured"
                + PRODUCT_COMPONENT_HELP)
        if not component:
            die("[<product>/]<component> or revision not specified and no default component is configured"
                + PRODUCT_COMPONENT_HELP)

    commits = get_commits(commit_or_revision_range)

    bug_references = list(extract_and_collate_bugs(commits))
    if len(bug_references) > 0:
        print ("Found existing bug reference%s in commit message%s:" %
               ("" if len(bug_references) == 1 else "s",
                "" if len(commits) == 1 else "s"))
        for reference, _ in bug_references:
            print " ", reference.get_url()
        if not prompt("File anyway?"):
            print "Aborting"
            sys.exit(0)

    if global_options.add_url:
        check_add_url(commits, is_add_url=False)

    template = StringIO()
    if len(commits) == 1:
        [no_reviewer_subject, _] = split_reviewer(commits[0].subject)
        template.write(no_reviewer_subject)
        template.write("\n")
    template.write("""
# Please enter the summary (first line) and description (other lines). Lines
# starting with '#' will be ignored.  Delete everything to abort.
#
# Product: %(product)s
# Component: %(component)s
# Patches to be attached:
""" % { 'product': product, 'component': component })
    for commit in reversed(commits):
        template.write("#   " + commit.id[0:7] + " " + commit.subject + "\n")

    lines = strip_lines(edit_template(template.getvalue()))

    if not len(lines):
        die("Empty summary, aborting")

    summary = lines[0]
    description = "".join(lines[1:]).strip()

    # If we have only one patch, and no other description for the bug was
    # specified, use the body of the commit as the description for the
    # bug rather than the description for the attachment.
    if len(commits) == 1 and description == "":
        description = get_body(commits[0])
        fill_comment = False
    else:
        fill_comment = True

    bug = Bug.create(get_tracker(), product, component, summary, description)

    if global_options.add_url:
        add_url(bug, commits)
        # Try to get the commits again, in case the user has used symbolic refs,
        # to ensure that we pick the commits after the rebase.
        commits = get_commits(commit_or_revision_range)

    attach_commits(bug, commits, fill_comment=fill_comment,
                   edit=global_options.edit)

def do_components(*args):
    server = tracker_get_bug_server(get_tracker())

    if len(args) == 1:
        product = args[0]
    else:
        product = get_default_product()
        if not product:
            die("<product> not specified and no default product is configured" + PRODUCT_COMPONENT_HELP)

    components = server.get_product_components(product)
    for c in components:
        print c


################################################################################

if len(sys.argv) > 1:
    command = sys.argv[1]
else:
    command = ''

sys.argv[1:2] = []

parser = OptionParser()
parser.add_option("-b", "--bugzilla", metavar="<host or alias>",
                  help="bug tracker to use")

def add_add_url_options():
    parser.add_option("-u", "--add-url", action="store_true",
                      help="rewrite commits to add the bug URL [default]")
    parser.add_option("-n", "--no-add-url", action="store_false", dest="add_url",
                      help="don't rewrite commits to add the bug URL")

def add_edit_option():
    parser.add_option("-e", "--edit", action="store_true",
                      help="allow editing the bugzilla comment")

def add_requestee_option():
    parser.add_option("-r", "--requestee", action="store", dest="requestee",
                      help="Only apply commits assigned to this requestee")

def add_whitespace_option():
    parser.add_option("-w", "--ignore-all-space", action="store_true", default=False,
                      help="pass -w option when generating a patch")

if command == 'add-url':
    parser.set_usage("git bz add-url [options] <bug reference> (<commit> | <revision range>)");
    min_args = max_args = 2
elif command == 'apply':
    parser.set_usage("git bz apply [options] <bug reference>");
    add_add_url_options()
    add_requestee_option()
    min_args = max_args = 1
elif command == 'attach':
    parser.set_usage("git bz attach [options] [<bug reference>] (<commit> | <revision range>)");
    add_add_url_options()
    add_edit_option()
    add_whitespace_option()
    min_args = 1
    max_args = 2
elif command == 'components':
    parser.set_usage("git bz components [options] [<product>]");
    min_args = 0
    max_args = 1
elif command == 'edit':
    parser.set_usage("git bz edit [options] (<bug reference> | <commit> | <revision range>)");
    add_add_url_options()
    min_args = max_args = 1
elif command == 'file':
    parser.set_usage("git bz file [options] [[<product>]]/<component>] (<commit> | <revision range>)");
    add_add_url_options()
    add_edit_option()
    add_whitespace_option()
    min_args = 1
    max_args = 2
else:
    print >>sys.stderr, "Usage: git bz [add-url|apply|attach|components|edit|file] [options]"
    sys.exit(1)

global_options, args = parser.parse_args()

if hasattr(global_options, 'add_url') and global_options.add_url is None:
    global_options.add_url = get_add_url()

if len(args) < min_args or len(args) > max_args:
    parser.print_usage()
    sys.exit(1)

if command == 'add-url':
    do_add_url(*args)
elif command == 'apply':
    do_apply(*args)
elif command == 'attach':
    do_attach(*args)
elif command == 'components':
    do_components(*args)
elif command == 'edit':
    do_edit(*args)
elif command == 'file':
    do_file(*args)

sys.exit(0)
